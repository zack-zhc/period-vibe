# Period Vibe - 开发指南与开发规范

## 1. 项目概述

### 1.1 项目简介
Period Vibe 是一款基于 Jetpack Compose 的 Android 生理期记录与管理应用，采用现代化的 Android 开发技术栈，遵循 Google 官方最佳实践。

### 1.2 技术愿景
- **现代化**：使用最新的 Android 技术栈和 Jetpack 库
- **可维护性**：清晰的架构分层和代码组织
- **可测试性**：高单元测试和集成测试覆盖率
- **高性能**：流畅的用户体验和优化的资源使用
- **安全性**：数据隐私保护和安全存储

---

## 2. 技术栈详解

### 2.1 核心技术栈

#### 2.1.1 开发语言
- **Kotlin**
  - 完全使用 Kotlin，不使用 Java
  - 使用 Kotlin 协程处理异步操作
  - 使用 Kotlin Flow 处理数据流
  - 使用 Kotlin DSL 配置 Gradle

#### 2.1.2 UI 框架
- **Jetpack Compose**
  - 声明式 UI 开发
  - Material Design 3 组件
  - 支持动态取色（Dynamic Color）
  - 自定义 Compose 组件库

#### 2.1.3 架构模式
- **MVVM + Clean Architecture**
  - Presentation Layer（表现层）：UI + ViewModel
  - Domain Layer（领域层）：Use Cases + Domain Models
  - Data Layer（数据层）：Repository + Data Sources

#### 2.1.4 依赖注入
- **Hilt**
  - 基于 Dagger 2 的依赖注入框架
  - 使用 @HiltViewModel 注解 ViewModel
  - 使用 @Inject 注解依赖
  - 使用 @Module 和 @Provides 提供依赖

#### 2.1.5 状态管理
- **StateFlow + SharedFlow**
  - 使用 StateFlow 管理状态
  - 使用 SharedFlow 处理事件
  - 使用 collectAsState() 在 Compose 中收集状态
  - 使用 LaunchedEffect 和 rememberCoroutineScope 处理副作用

#### 2.1.6 导航
- **Jetpack Navigation Compose**
  - 类型安全的导航
  - 支持深度链接
  - 支持嵌套导航图
  - 使用 NavHost 和 NavController

#### 2.1.7 数据库
- **Room Database**
  - 官方推荐的 ORM 框架
  - 支持 Flow 响应式查询
  - 支持数据库迁移
  - 支持 @Query、@Insert、@Update、@Delete 注解

#### 2.1.8 异步处理
- **Kotlin Coroutines**
  - 使用协程处理异步操作
  - 使用 Dispatchers.IO 处理 I/O 操作
  - 使用 Dispatchers.Main 处理 UI 更新
  - 使用 viewModelScope 和 lifecycleScope

#### 2.1.9 日期时间处理
- **java.time API**
  - 使用 LocalDate 处理日期
  - 使用 LocalDateTime 处理日期时间
  - 使用 Period 计算日期差
  - 使用 DateTimeFormatter 格式化日期

#### 2.1.10 图表库
- **Vico**
  - 轻量级图表库
  - 支持 Compose 集成
  - 支持折线图、柱状图等
  - 高性能渲染

#### 2.1.11 通知与任务调度
- **WorkManager**
  - 后台任务调度
  - 支持周期性任务
  - 支持约束条件（网络、充电等）
  - 支持链式任务

- **Android Notification Manager**
  - 系统通知
  - 支持通知渠道
  - 支持大文本和图片
  - 支持点击跳转

#### 2.1.12 图像加载
- **Coil**
  - 轻量级图片加载库
  - 支持 Compose
  - 支持内存和磁盘缓存
  - 支持 GIF 和 WebP

#### 2.1.13 日志
- **Timber**
  - 简化日志输出
  - 支持调试和发布环境
  - 支持自定义日志策略

#### 2.1.14 数据序列化
- **Kotlinx Serialization**
  - JSON 序列化/反序列化
  - 支持数据类
  - 支持自定义序列化器

#### 2.1.15 测试
- **JUnit 5**
  - 单元测试框架
  - 支持 Kotlin

- **Mockk**
  - Kotlin Mock 框架
  - 比 Mockito 更适合 Kotlin

- **Kotlin Coroutines Test**
  - 协程测试支持
  - 测试调度器

- **Compose UI Test**
  - Compose UI 测试
  - 支持 Semantics

### 2.2 依赖版本管理

#### 2.2.1 Gradle 版本目录（libs.versions.toml）
暂不处理

---

## 3. 项目架构

### 3.1 Clean Architecture 分层

```
┌─────────────────────────────────────────────────────────────┐
│                     Presentation Layer                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   Screens   │  │  ViewModels │  │     UI Components   │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      Domain Layer                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │  Use Cases  │  │ Domain Model│  │   Repository Intf   │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                       Data Layer                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ Repositories│  │ Data Sources│  │    Room Database    │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 目录结构

```
app/
├── src/
│   ├── main/
│   │   ├── java/com/periodvibe/
│   │   │   ├── data/
│   │   │   │   ├── local/
│   │   │   │   │   ├── dao/
│   │   │   │   │   ├── entity/
│   │   │   │   │   ├── converter/
│   │   │   │   │   └── database/
│   │   │   │   ├── repository/
│   │   │   │   └── mapper/
│   │   │   ├── domain/
│   │   │   │   ├── model/
│   │   │   │   ├── repository/
│   │   │   │   └── usecase/
│   │   │   ├── presentation/
│   │   │   │   ├── home/
│   │   │   │   │   ├── HomeScreen.kt
│   │   │   │   │   ├── HomeViewModel.kt
│   │   │   │   │   └── HomeUiState.kt
│   │   │   │   ├── calendar/
│   │   │   │   ├── history/
│   │   │   │   ├── settings/
│   │   │   │   ├── record/
│   │   │   │   ├── navigation/
│   │   │   │   └── theme/
│   │   │   ├── di/
│   │   │   │   ├── AppModule.kt
│   │   │   │   ├── DatabaseModule.kt
│   │   │   │   ├── RepositoryModule.kt
│   │   │   │   └── UseCaseModule.kt
│   │   │   ├── util/
│   │   │   │   ├── DateUtils.kt
│   │   │   │   ├── PeriodCalculator.kt
│   │   │   │   └── Extensions.kt
│   │   │   └── PeriodVibeApp.kt
│   │   ├── res/
│   │   │   ├── drawable/
│   │   │   ├── values/
│   │   │   │   ├── colors.xml
│   │   │   │   ├── strings.xml
│   │   │   │   └── themes.xml
│   │   │   └── mipmap/
│   │   └── AndroidManifest.xml
│   ├── test/
│   │   └── java/com/periodvibe/
│   │       ├── domain/
│   │       ├── data/
│   │       └── util/
│   └── androidTest/
│       └── java/com/periodvibe/
│           ├── presentation/
│           └── data/
├── build.gradle.kts
└── proguard-rules.pro
```

---

## 4. 数据库设计

### 4.1 数据库选型：Room Database

**选择理由**：
- Google 官方推荐的 ORM 框架
- 编译时 SQL 验证，减少运行时错误
- 支持 Flow 响应式查询
- 支持数据库迁移
- 与 Jetpack 组件深度集成
- 支持多平台（Android、iOS、Desktop）

### 4.2 数据库配置

#### 4.2.1 数据库版本与迁移策略
```kotlin
@Database(
    entities = [
        CycleEntity::class,
        DailyRecordEntity::class,
        SettingsEntity::class
    ],
    version = 1,
    exportSchema = true
)
@TypeConverters(Converters::class)
abstract class PeriodVibeDatabase : RoomDatabase() {
    
    abstract fun cycleDao(): CycleDao
    abstract fun dailyRecordDao(): DailyRecordDao
    abstract fun settingsDao(): SettingsDao
    
    companion object {
        const val DATABASE_NAME = "period_vibe.db"
    }
}
```

#### 4.2.2 数据库依赖注入
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    @Provides
    @Singleton
    fun provideDatabase(
        @ApplicationContext context: Context
    ): PeriodVibeDatabase {
        return Room.databaseBuilder(
            context,
            PeriodVibeDatabase::class.java,
            PeriodVibeDatabase.DATABASE_NAME
        )
            .fallbackToDestructiveMigration()
            .build()
    }
    
    @Provides
    fun provideCycleDao(database: PeriodVibeDatabase): CycleDao {
        return database.cycleDao()
    }
    
    @Provides
    fun provideDailyRecordDao(database: PeriodVibeDatabase): DailyRecordDao {
        return database.dailyRecordDao()
    }
    
    @Provides
    fun provideSettingsDao(database: PeriodVibeDatabase): SettingsDao {
        return database.settingsDao()
    }
}
```

### 4.3 数据表设计

#### 4.3.1 CycleEntity（周期表）
```kotlin
@Entity(tableName = "cycles")
data class CycleEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    
    @ColumnInfo(name = "start_date")
    val startDate: LocalDate,
    
    @ColumnInfo(name = "end_date")
    val endDate: LocalDate?,
    
    @ColumnInfo(name = "cycle_length")
    val cycleLength: Int,
    
    @ColumnInfo(name = "period_length")
    val periodLength: Int,
    
    @ColumnInfo(name = "created_at")
    val createdAt: LocalDateTime = LocalDateTime.now(),
    
    @ColumnInfo(name = "updated_at")
    val updatedAt: LocalDateTime = LocalDateTime.now()
)
```

#### 4.3.2 DailyRecordEntity（每日记录表）
```kotlin
@Entity(
    tableName = "daily_records",
    foreignKeys = [
        ForeignKey(
            entity = CycleEntity::class,
            parentColumns = ["id"],
            childColumns = ["cycle_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["date"], unique = true),
        Index(value = ["cycle_id"])
    ]
)
data class DailyRecordEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    
    @ColumnInfo(name = "date")
    val date: LocalDate,
    
    @ColumnInfo(name = "cycle_id")
    val cycleId: Long?,
    
    @ColumnInfo(name = "is_period")
    val isPeriod: Boolean,
    
    @ColumnInfo(name = "flow_level")
    val flowLevel: FlowLevel?,
    
    @ColumnInfo(name = "symptoms")
    val symptoms: List<Symptom>,
    
    @ColumnInfo(name = "notes")
    val notes: String?,
    
    @ColumnInfo(name = "created_at")
    val createdAt: LocalDateTime = LocalDateTime.now(),
    
    @ColumnInfo(name = "updated_at")
    val updatedAt: LocalDateTime = LocalDateTime.now()
)
```

#### 4.3.3 SettingsEntity（设置表）
```kotlin
@Entity(tableName = "settings")
data class SettingsEntity(
    @PrimaryKey
    val id: Int = 1,
    
    @ColumnInfo(name = "cycle_length_default")
    val cycleLengthDefault: Int = 28,
    
    @ColumnInfo(name = "period_length_default")
    val periodLengthDefault: Int = 5,
    
    @ColumnInfo(name = "notification_enabled")
    val notificationEnabled: Boolean = true,
    
    @ColumnInfo(name = "notification_days_before")
    val notificationDaysBefore: Int = 3,
    
    @ColumnInfo(name = "notification_time")
    val notificationTime: String = "09:00",
    
    @ColumnInfo(name = "theme_mode")
    val themeMode: String = "system",
    
    @ColumnInfo(name = "app_lock_enabled")
    val appLockEnabled: Boolean = false,
    
    @ColumnInfo(name = "privacy_mode_enabled")
    val privacyModeEnabled: Boolean = false
)
```

### 4.4 DAO 接口设计

#### 4.4.1 CycleDao
```kotlin
@Dao
interface CycleDao {
    
    @Query("SELECT * FROM cycles ORDER BY start_date DESC")
    fun getAllCycles(): Flow<List<CycleEntity>>
    
    @Query("SELECT * FROM cycles WHERE id = :id")
    suspend fun getCycleById(id: Long): CycleEntity?
    
    @Query("SELECT * FROM cycles ORDER BY start_date DESC LIMIT 1")
    suspend fun getLatestCycle(): CycleEntity?
    
    @Query("SELECT * FROM cycles WHERE start_date <= :date AND (end_date IS NULL OR end_date >= :date)")
    suspend fun getCycleByDate(date: LocalDate): CycleEntity?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertCycle(cycle: CycleEntity): Long
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertCycles(cycles: List<CycleEntity>)
    
    @Update
    suspend fun updateCycle(cycle: CycleEntity)
    
    @Delete
    suspend fun deleteCycle(cycle: CycleEntity)
    
    @Query("DELETE FROM cycles WHERE id = :id")
    suspend fun deleteCycleById(id: Long)
    
    @Query("SELECT COUNT(*) FROM cycles")
    suspend fun getCycleCount(): Int
}
```

#### 4.4.2 DailyRecordDao
```kotlin
@Dao
interface DailyRecordDao {
    
    @Query("SELECT * FROM daily_records ORDER BY date DESC")
    fun getAllRecords(): Flow<List<DailyRecordEntity>>
    
    @Query("SELECT * FROM daily_records WHERE date = :date")
    suspend fun getRecordByDate(date: LocalDate): DailyRecordEntity?
    
    @Query("SELECT * FROM daily_records WHERE date BETWEEN :startDate AND :endDate ORDER BY date")
    fun getRecordsByDateRange(startDate: LocalDate, endDate: LocalDate): Flow<List<DailyRecordEntity>>
    
    @Query("SELECT * FROM daily_records WHERE cycle_id = :cycleId ORDER BY date")
    fun getRecordsByCycleId(cycleId: Long): Flow<List<DailyRecordEntity>>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertRecord(record: DailyRecordEntity): Long
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertRecords(records: List<DailyRecordEntity>)
    
    @Update
    suspend fun updateRecord(record: DailyRecordEntity)
    
    @Delete
    suspend fun deleteRecord(record: DailyRecordEntity)
    
    @Query("DELETE FROM daily_records WHERE date = :date")
    suspend fun deleteRecordByDate(date: LocalDate)
}
```

### 4.5 类型转换器

```kotlin
class Converters {
    
    @TypeConverter
    fun fromLocalDate(value: LocalDate?): String? {
        return value?.toString()
    }
    
    @TypeConverter
    fun toLocalDate(value: String?): LocalDate? {
        return value?.let { LocalDate.parse(it) }
    }
    
    @TypeConverter
    fun fromLocalDateTime(value: LocalDateTime?): String? {
        return value?.toString()
    }
    
    @TypeConverter
    fun toLocalDateTime(value: String?): LocalDateTime? {
        return value?.let { LocalDateTime.parse(it) }
    }
    
    @TypeConverter
    fun fromFlowLevel(value: FlowLevel?): String? {
        return value?.name
    }
    
    @TypeConverter
    fun toFlowLevel(value: String?): FlowLevel? {
        return value?.let { FlowLevel.valueOf(it) }
    }
    
    @TypeConverter
    fun fromSymptomsList(value: List<Symptom>?): String? {
        return value?.joinToString(",") { it.name }
    }
    
    @TypeConverter
    fun toSymptomsList(value: String?): List<Symptom>? {
        return value?.split(",")?.mapNotNull { Symptom.valueOf(it) }
    }
}
```

---

## 5. 导航设计

### 5.1 导航库选型：Jetpack Navigation Compose

**选择理由**：
- Google 官方推荐的导航解决方案
- 类型安全的导航参数
- 支持深度链接
- 与 ViewModel 和 SavedStateHandle 集成
- 支持嵌套导航图
- 支持动画过渡

### 5.2 导航路由定义

```kotlin
sealed class Screen(val route: String) {
    object Home : Screen("home")
    object Calendar : Screen("calendar")
    object History : Screen("history")
    object Settings : Screen("settings")
    object Record : Screen("record?date={date}") {
        fun createRoute(date: LocalDate? = null): String {
            return "record?date=${date?.toString() ?: ""}"
        }
    }
    object CycleDetail : Screen("cycle_detail/{cycleId}") {
        fun createRoute(cycleId: Long): String {
            return "cycle_detail/$cycleId"
        }
    }
    object Statistics : Screen("statistics")
    object Welcome : Screen("welcome")
    object InitialSetup : Screen("initial_setup")
}
```

### 5.3 导航图配置

```kotlin
@Composable
fun PeriodVibeNavGraph(
    navController: NavController,
    startDestination: String
) {
    NavHost(
        navController = navController,
        startDestination = startDestination
    ) {
        composable(Screen.Home.route) {
            HomeScreen(
                onNavigateToRecord = { date ->
                    navController.navigate(Screen.Record.createRoute(date))
                },
                onNavigateToCalendar = {
                    navController.navigate(Screen.Calendar.route)
                },
                onNavigateToHistory = {
                    navController.navigate(Screen.History.route)
                },
                onNavigateToSettings = {
                    navController.navigate(Screen.Settings.route)
                }
            )
        }
        
        composable(Screen.Calendar.route) {
            CalendarScreen(
                onNavigateToRecord = { date ->
                    navController.navigate(Screen.Record.createRoute(date))
                },
                onNavigateBack = {
                    navController.popBackStack()
                }
            )
        }
        
        composable(
            route = Screen.Record.route,
            arguments = listOf(
                navArgument("date") {
                    type = NavType.StringType
                    nullable = true
                    defaultValue = null
                }
            )
        ) { backStackEntry ->
            val dateParam = backStackEntry.arguments?.getString("date")
            val date = if (dateParam.isNullOrEmpty()) {
                LocalDate.now()
            } else {
                LocalDate.parse(dateParam)
            }
            
            RecordScreen(
                date = date,
                onNavigateBack = {
                    navController.popBackStack()
                }
            )
        }
        
        composable(Screen.History.route) {
            HistoryScreen(
                onNavigateToCycleDetail = { cycleId ->
                    navController.navigate(Screen.CycleDetail.createRoute(cycleId))
                },
                onNavigateBack = {
                    navController.popBackStack()
                }
            )
        }
        
        composable(
            route = Screen.CycleDetail.route,
            arguments = listOf(
                navArgument("cycleId") {
                    type = NavType.LongType
                }
            )
        ) { backStackEntry ->
            val cycleId = backStackEntry.arguments?.getLong("cycleId") ?: return@composable
            
            CycleDetailScreen(
                cycleId = cycleId,
                onNavigateBack = {
                    navController.popBackStack()
                }
            )
        }
        
        composable(Screen.Settings.route) {
            SettingsScreen(
                onNavigateToStatistics = {
                    navController.navigate(Screen.Statistics.route)
                },
                onNavigateBack = {
                    navController.popBackStack()
                }
            )
        }
        
        composable(Screen.Statistics.route) {
            StatisticsScreen(
                onNavigateBack = {
                    navController.popBackStack()
                }
            )
        }
    }
}
```

### 5.4 底部导航栏集成

```kotlin
@Composable
fun MainScreen(
    navController: NavController,
    isFirstLaunch: Boolean
) {
    val bottomNavItems = listOf(
        BottomNavItem.Home,
        BottomNavItem.Calendar,
        BottomNavItem.History,
        BottomNavItem.Settings
    )
    
    val navBackStackEntry by navController.currentBackStackEntryFlow.collectAsState()
    val currentRoute = navBackStackEntry?.destination?.route
    
    Scaffold(
        bottomBar = {
            if (currentRoute in bottomNavItems.map { it.route }) {
                PeriodBottomNavigation(
                    currentRoute = currentRoute ?: Screen.Home.route,
                    onNavigate = { route ->
                        navController.navigate(route) {
                            popUpTo(navController.graph.findStartDestination().id) {
                                saveState = true
                            }
                            launchSingleTop = true
                            restoreState = true
                        }
                    }
                )
            }
        }
    ) { paddingValues ->
        PeriodVibeNavGraph(
            navController = navController,
            startDestination = if (isFirstLaunch) Screen.Welcome.route else Screen.Home.route
        )
    }
}
```

---

## 6. 依赖注入设计

### 6.1 Hilt 模块组织

#### 6.1.1 AppModule（应用级模块）
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    
    @Provides
    @Singleton
    fun provideApplication(@ApplicationContext context: Context): PeriodVibeApplication {
        return context as PeriodVibeApplication
    }
    
    @Provides
    @Singleton
    fun provideCoroutineDispatcher(): CoroutineDispatcher {
        return Dispatchers.IO
    }
}
```

#### 6.1.2 RepositoryModule（仓储模块）
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {
    
    @Provides
    @Singleton
    fun provideCycleRepository(
        cycleDao: CycleDao,
        dailyRecordDao: DailyRecordDao
    ): CycleRepository {
        return CycleRepositoryImpl(cycleDao, dailyRecordDao)
    }
    
    @Provides
    @Singleton
    fun provideDailyRecordRepository(
        dailyRecordDao: DailyRecordDao
    ): DailyRecordRepository {
        return DailyRecordRepositoryImpl(dailyRecordDao)
    }
    
    @Provides
    @Singleton
    fun provideSettingsRepository(
        settingsDao: SettingsDao
    ): SettingsRepository {
        return SettingsRepositoryImpl(settingsDao)
    }
}
```

#### 6.1.3 UseCaseModule（用例模块）
```kotlin
@Module
@InstallIn(ViewModelComponent::class)
object UseCaseModule {
    
    @Provides
    fun provideGetCurrentCycleUseCase(
        cycleRepository: CycleRepository
    ): GetCurrentCycleUseCase {
        return GetCurrentCycleUseCase(cycleRepository)
    }
    
    @Provides
    fun provideGetDailyRecordsUseCase(
        dailyRecordRepository: DailyRecordRepository
    ): GetDailyRecordsUseCase {
        return GetDailyRecordsUseCase(dailyRecordRepository)
    }
    
    @Provides
    fun provideSaveDailyRecordUseCase(
        dailyRecordRepository: DailyRecordRepository,
        cycleRepository: CycleRepository
    ): SaveDailyRecordUseCase {
        return SaveDailyRecordUseCase(dailyRecordRepository, cycleRepository)
    }
    
    @Provides
    fun providePredictNextPeriodUseCase(
        cycleRepository: CycleRepository
    ): PredictNextPeriodUseCase {
        return PredictNextPeriodUseCase(cycleRepository)
    }
}
```

### 6.2 ViewModel 注入

```kotlin
@HiltViewModel
class HomeViewModel @Inject constructor(
    private val getCurrentCycleUseCase: GetCurrentCycleUseCase,
    private val predictNextPeriodUseCase: PredictNextPeriodUseCase,
    private val getDailyRecordsUseCase: GetDailyRecordsUseCase
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(HomeUiState())
    val uiState: StateFlow<HomeUiState> = _uiState.asStateFlow()
    
    init {
        loadHomeData()
    }
    
    private fun loadHomeData() {
        viewModelScope.launch {
            combine(
                getCurrentCycleUseCase(),
                predictNextPeriodUseCase(),
                getDailyRecordsUseCase(LocalDate.now(), LocalDate.now().plusDays(7))
            ) { cycle, prediction, records ->
                HomeUiState(
                    currentCycle = cycle,
                    prediction = prediction,
                    recentRecords = records,
                    isLoading = false
                )
            }.collect { state ->
                _uiState.value = state
            }
        }
    }
}
```

---

## 7. 状态管理

### 7.1 UI State 模式

#### 7.1.1 UiState 数据类
```kotlin
data class HomeUiState(
    val isLoading: Boolean = true,
    val currentCycle: Cycle? = null,
    val prediction: Prediction? = null,
    val recentRecords: List<DailyRecord> = emptyList(),
    val hasCurrentCycle: Boolean = false,
    val error: String? = null
)
```

**说明**：
- `hasCurrentCycle`：用于判断是否有当前活跃的周期，基于 `Cycle.isCompleted` 字段
- 当 `hasCurrentCycle` 为 `true` 时，FAB 显示"结束周期"和"修改记录"选项
- 当 `hasCurrentCycle` 为 `false` 时，FAB 显示"新建周期"和"记录症状"选项

#### 7.1.2 UiEvent 密封类
```kotlin
sealed class HomeUiEvent {
    object NavigateToRecord : HomeUiEvent()
    data class ShowError(val message: String) : HomeUiEvent()
    object RefreshData : HomeUiEvent()
}
```

### 7.2 ViewModel 模式

```kotlin
@HiltViewModel
class HomeViewModel @Inject constructor(
    private val getCurrentCycleUseCase: GetCurrentCycleUseCase,
    private val predictNextPeriodUseCase: PredictNextPeriodUseCase
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(HomeUiState())
    val uiState: StateFlow<HomeUiState> = _uiState.asStateFlow()
    
    private val _uiEvent = MutableSharedFlow<HomeUiEvent>()
    val uiEvent: SharedFlow<HomeUiEvent> = _uiEvent.asSharedFlow()
    
    fun onEvent(event: HomeEvent) {
        when (event) {
            HomeEvent.Refresh -> refreshData()
            HomeEvent.NavigateToRecord -> viewModelScope.launch {
                _uiEvent.emit(HomeUiEvent.NavigateToRecord)
            }
        }
    }
    
    private fun refreshData() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            try {
                val cycle = getCurrentCycleUseCase()
                val prediction = predictNextPeriodUseCase()
                _uiState.value = _uiState.value.copy(
                    currentCycle = cycle,
                    prediction = prediction,
                    isLoading = false
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    error = e.message,
                    isLoading = false
                )
            }
        }
    }
}
```

### 7.3 Compose 状态收集

```kotlin
@Composable
fun HomeScreen(
    viewModel: HomeViewModel = hiltViewModel(),
    onNavigateToRecord: (LocalDate?) -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()
    val context = LocalContext.current
    
    LaunchedEffect(Unit) {
        viewModel.uiEvent.collect { event ->
            when (event) {
                HomeUiEvent.NavigateToRecord -> onNavigateToRecord(null)
                is HomeUiEvent.ShowError -> {
                    Toast.makeText(context, event.message, Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
    
    if (uiState.isLoading) {
        LoadingIndicator()
    } else {
        HomeContent(
            currentCycle = uiState.currentCycle,
            prediction = uiState.prediction,
            recentRecords = uiState.recentRecords,
            onRecordClick = { onNavigateToRecord(it) },
            onRefresh = { viewModel.onEvent(HomeEvent.Refresh) }
        )
    }
}
```

---

## 8. 代码规范

### 8.1 Kotlin 代码规范

#### 8.1.1 命名规范
- **类名**：PascalCase，例如 `HomeScreen`
- **函数名**：camelCase，例如 `loadData()`
- **变量名**：camelCase，例如 `userName`
- **常量名**：UPPER_SNAKE_CASE，例如 `MAX_RETRY_COUNT`
- **私有属性**：下划线前缀，例如 `_uiState`

#### 8.1.2 文件组织
```kotlin
// 1. 文件头注释
// 2. 包声明
package com.periodvibe.presentation.home

// 3. 导入（按字母顺序）
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.hilt.navigation.compose.hiltViewModel
// ...

// 4. 类/函数定义
@Composable
fun HomeScreen(
    viewModel: HomeViewModel = hiltViewModel()
) {
    // ...
}
```

#### 8.1.3 注释规范
```kotlin
/**
 * 首页屏幕
 * 
 * 显示当前周期状态和快捷操作入口
 * 
 * @param viewModel 首页 ViewModel
 * @param onNavigateToRecord 导航到记录页面的回调
 */
@Composable
fun HomeScreen(
    viewModel: HomeViewModel = hiltViewModel(),
    onNavigateToRecord: (LocalDate?) -> Unit
) {
    // TODO: 实现加载状态
    val uiState by viewModel.uiState.collectAsState()
    
    // FIXME: 修复日期显示问题
    // NOTE: 这里使用的是系统默认时区
}
```

### 8.2 Compose 代码规范

#### 8.2.1 Composable 函数规范
```kotlin
@Composable
fun MyComposable(
    modifier: Modifier = Modifier,
    // 必需参数在前，可选参数在后
    requiredParam: String,
    optionalParam: Int = 0,
    // 回调函数放在最后
    onClick: () -> Unit = {},
    onValueChange: (String) -> Unit = {}
) {
    // 使用 modifier 作为第一个参数
    Column(
        modifier = modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        // ...
    }
}
```

#### 8.2.2 记录弹窗实现规范

**RecordBottomSheet 实现要点**：

1. **智能判断模式**：
   - 根据当前日期是否有记录，自动切换到编辑模式或新增模式
   - 编辑模式显示"编辑记录"标题，自动填充已有数据

2. **参数设计**：
```kotlin
@Composable
fun RecordBottomSheet(
    initialDate: LocalDate = LocalDate.now(),
    initialFlowLevel: FlowLevel? = null,
    initialSymptoms: List<Symptom> = emptyList(),
    initialNotes: String? = null,
    recordMode: RecordMode = RecordMode.AUTO,
    hasCurrentCycle: Boolean = false,
    existingRecord: DailyRecord? = null,  // 新增：现有记录参数
    onDismiss: () -> Unit,
    onSave: (flowLevel: FlowLevel?, symptoms: List<Symptom>, notes: String?) -> Unit
)
```

3. **状态初始化**：
```kotlin
var selectedDate by remember { mutableStateOf(existingRecord?.date ?: initialDate) }
var flowLevel by remember { mutableStateOf(existingRecord?.flowLevel ?: initialFlowLevel) }
val selectedSymptoms = remember { mutableStateListOf<Symptom>().apply { addAll(existingRecord?.symptoms ?: initialSymptoms) } }
var notes by remember { mutableStateOf(existingRecord?.notes ?: initialNotes ?: "") }
```

4. **标题显示逻辑**：
```kotlin
Text(
    text = if (existingRecord != null) {
        "编辑记录"
    } else when {
        hasCurrentCycle -> "记录今日状态"
        selectedMode == RecordMode.NEW_CYCLE -> "开始新周期"
        selectedMode == RecordMode.SYMPTOM_ONLY -> "记录症状"
        else -> "选择记录类型"
    }
)
```

#### 8.2.3 状态提升原则
```kotlin
// 错误示例：状态未提升
@Composable
fun BadExample() {
    var count by remember { mutableStateOf(0) }
    Button(onClick = { count++ }) {
        Text("Count: $count")
    }
}

// 正确示例：状态提升
@Composable
fun GoodExample(
    count: Int,
    onIncrement: () -> Unit
) {
    Button(onClick = onIncrement) {
        Text("Count: $count")
    }
}
```

#### 8.2.3 重组优化
```kotlin
@Composable
fun OptimizedList(
    items: List<Item>,
    onItemClick: (Item) -> Unit
) {
    LazyColumn(
        modifier = Modifier.fillMaxSize()
    ) {
        items(
            items = items,
            key = { it.id }
        ) { item ->
            // 使用 remember 避免不必要的重组
            val backgroundColor by remember(item.id) {
                derivedStateOf { if (item.isSelected) Color.Blue else Color.White }
            }
            
            ItemCard(
                item = item,
                backgroundColor = backgroundColor,
                onClick = { onItemClick(item) }
            )
        }
    }
}
```

### 8.3 架构规范

#### 8.3.1 Repository 实现
```kotlin
class CycleRepositoryImpl @Inject constructor(
    private val cycleDao: CycleDao,
    private val dailyRecordDao: DailyRecordDao
) : CycleRepository {
    
    override fun getAllCycles(): Flow<List<Cycle>> {
        return cycleDao.getAllCycles()
            .map { entities -> entities.map { it.toDomain() } }
    }
    
    override suspend fun getCycleById(id: Long): Cycle? {
        return cycleDao.getCycleById(id)?.toDomain()
    }
    
    override suspend fun saveCycle(cycle: Cycle): Long {
        return cycleDao.insertCycle(cycle.toEntity())
    }
}
```

#### 8.3.2 UseCase 实现
```kotlin
class GetCurrentCycleUseCase @Inject constructor(
    private val cycleRepository: CycleRepository
) {
    operator fun invoke(): Flow<Cycle?> {
        return cycleRepository.getLatestCycle()
            .map { cycle ->
                if (cycle == null) null
                else if (cycle.endDate == null) cycle
                else null
            }
    }
}
```

---

## 9. 测试策略

### 9.1 单元测试

#### 9.1.1 UseCase 测试
```kotlin
@ExperimentalCoroutinesApi
class GetCurrentCycleUseCaseTest {
    
    private lateinit var useCase: GetCurrentCycleUseCase
    private lateinit var repository: CycleRepository
    
    @Before
    fun setup() {
        repository = mockk()
        useCase = GetCurrentCycleUseCase(repository)
    }
    
    @Test
    fun `invoke returns current cycle when exists`() = runTest {
        val expectedCycle = Cycle(
            id = 1,
            startDate = LocalDate.now().minusDays(10),
            endDate = null,
            cycleLength = 28,
            periodLength = 5
        )
        
        every { repository.getLatestCycle() } returns flowOf(expectedCycle)
        
        val result = useCase().first()
        
        assertEquals(expectedCycle, result)
        verify(exactly = 1) { repository.getLatestCycle() }
    }
}
```

#### 9.1.2 ViewModel 测试
```kotlin
@ExperimentalCoroutinesApi
class HomeViewModelTest {
    
    private lateinit var viewModel: HomeViewModel
    private val getCurrentCycleUseCase: GetCurrentCycleUseCase = mockk()
    private val predictNextPeriodUseCase: PredictNextPeriodUseCase = mockk()
    
    @Before
    fun setup() {
        every { getCurrentCycleUseCase() } returns flowOf(null)
        every { predictNextPeriodUseCase() } returns flowOf(null)
        
        viewModel = HomeViewModel(
            getCurrentCycleUseCase,
            predictNextPeriodUseCase
        )
    }
    
    @Test
    fun `initial state is loading`() = runTest {
        assertEquals(true, viewModel.uiState.value.isLoading)
    }
}
```

### 9.2 UI 测试

#### 9.2.1 Compose UI 测试
```kotlin
class HomeScreenTest {
    
    @get:Rule
    val composeTestRule = createComposeRule()
    
    @Test
    fun homeScreen_displaysCycleInfo() {
        val cycle = Cycle(
            id = 1,
            startDate = LocalDate.now().minusDays(10),
            endDate = null,
            cycleLength = 28,
            periodLength = 5
        )
        
        composeTestRule.setContent {
            HomeScreen(
                viewModel = mockViewModel(cycle),
                onNavigateToRecord = {}
            )
        }
        
        composeTestRule
            .onNodeWithText("第 10 天")
            .assertIsDisplayed()
    }
}
```

### 9.3 集成测试

#### 9.3.1 数据库测试
```kotlin
@RunWith(AndroidJUnit4::class)
class CycleDaoTest {
    
    private lateinit var database: PeriodVibeDatabase
    private lateinit var cycleDao: CycleDao
    
    @Before
    fun createDb() {
        val context = ApplicationProvider.getApplicationContext<Context>()
        database = Room.inMemoryDatabaseBuilder(
            context,
            PeriodVibeDatabase::class.java
        ).build()
        cycleDao = database.cycleDao()
    }
    
    @After
    fun closeDb() {
        database.close()
    }
    
    @Test
    fun insertCycleAndGetById() = runTest {
        val cycle = CycleEntity(
            startDate = LocalDate.now(),
            endDate = null,
            cycleLength = 28,
            periodLength = 5
        )
        
        val id = cycleDao.insertCycle(cycle)
        val retrieved = cycleDao.getCycleById(id)
        
        assertNotNull(retrieved)
        assertEquals(cycle.startDate, retrieved?.startDate)
    }
}
```

---

## 10. 性能优化

### 10.1 Compose 性能优化

#### 10.1.1 使用 remember 和 derivedStateOf
```kotlin
@Composable
fun ExpensiveComputation(
    data: List<Item>
) {
    val sortedData by remember(data) {
        derivedStateOf {
            data.sortedBy { it.name }
        }
    }
    
    LazyColumn {
        items(sortedData) { item ->
            ItemRow(item)
        }
    }
}
```

#### 10.1.2 使用 key 优化列表
```kotlin
@Composable
fun OptimizedList(
    items: List<Item>
) {
    LazyColumn {
        items(
            items = items,
            key = { it.id }
        ) { item ->
            ItemRow(item)
        }
    }
}
```

### 10.2 数据库优化

#### 10.2.1 使用索引
```kotlin
@Entity(
    tableName = "daily_records",
    indices = [
        Index(value = ["date"], unique = true),
        Index(value = ["cycle_id"])
    ]
)
data class DailyRecordEntity(...)
```

#### 10.2.2 使用 Flow 响应式查询
```kotlin
@Query("SELECT * FROM cycles ORDER BY start_date DESC")
fun getAllCycles(): Flow<List<CycleEntity>>
```

### 10.3 内存优化

#### 10.3.1 图片加载优化
```kotlin
AsyncImage(
    model = ImageRequest.Builder(LocalContext.current)
        .data(imageUrl)
        .crossfade(true)
        .memoryCachePolicy(CachePolicy.ENABLED)
        .diskCachePolicy(CachePolicy.ENABLED)
        .build(),
    contentDescription = null,
    modifier = Modifier.size(100.dp)
)
```

---

## 11. 安全规范

### 11.1 数据加密

#### 11.1.1 使用 EncryptedSharedPreferences
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object SecurityModule {
    
    @Provides
    @Singleton
    fun provideEncryptedSharedPreferences(
        @ApplicationContext context: Context
    ): SharedPreferences {
        val masterKey = MasterKey.Builder(context)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build()
        
        return EncryptedSharedPreferences.create(
            context,
            "secure_prefs",
            masterKey,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        )
    }
}
```

### 11.2 应用锁

#### 11.2.1 生物识别认证
```kotlin
@Composable
fun BiometricAuthScreen(
    onAuthSuccess: () -> Unit,
    onAuthFailed: () -> Unit
) {
    val context = LocalContext.current
    val biometricPrompt = BiometricPrompt(
        context,
        ContextCompat.getMainExecutor(context),
        object : BiometricPrompt.AuthenticationCallback() {
            override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                onAuthSuccess()
            }
            
            override fun onAuthenticationFailed() {
                onAuthFailed()
            }
        }
    )
    
    val promptInfo = BiometricPrompt.PromptInfo.Builder()
        .setTitle("生物识别验证")
        .setSubtitle("请使用指纹或面容解锁")
        .setNegativeButtonText("取消")
        .build()
    
    LaunchedEffect(Unit) {
        biometricPrompt.authenticate(promptInfo)
    }
}
```

---

## 12. 构建与发布

### 12.1 构建配置

#### 12.1.1 build.gradle.kts (app)
```kotlin
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("com.google.dagger.hilt.android")
    id("com.google.devtools.ksp")
    id("kotlinx-serialization")
}

android {
    namespace = "com.periodvibe"
    compileSdk = libs.versions.compileSdk.get().toInt()

    defaultConfig {
        applicationId = "com.periodvibe"
        minSdk = libs.versions.minSdk.get().toInt()
        targetSdk = libs.versions.targetSdk.get().toInt()
        versionCode = 1
        versionName = "1.0.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
        debug {
            isMinifyEnabled = false
            applicationIdSuffix = ".debug"
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }

    buildFeatures {
        compose = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = libs.versions.compose.compiler.get()
    }

    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
}

dependencies {
    implementation(libs.kotlin.stdlib)
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.appcompat)
    
    implementation(platform(libs.compose.bom))
    implementation(libs.compose.ui)
    implementation(libs.compose.ui.graphics)
    implementation(libs.compose.ui.tooling.preview)
    implementation(libs.compose.material3)
    implementation(libs.compose.material.icons)
    
    implementation(libs.compose.activity)
    implementation(libs.compose.lifecycle.runtime)
    implementation(libs.compose.lifecycle.viewmodel)
    
    implementation(libs.navigation.compose)
    
    implementation(libs.lifecycle.runtime.ktx)
    implementation(libs.lifecycle.viewmodel.ktx)
    implementation(libs.lifecycle.livedata.ktx)
    
    implementation(libs.room.runtime)
    implementation(libs.room.ktx)
    ksp(libs.room.compiler)
    
    implementation(libs.work.runtime.ktx)
    implementation(libs.work.hilt)
    
    implementation(libs.hilt.android)
    kapt(libs.hilt.compiler)
    implementation(libs.hilt.navigation.compose)
    
    implementation(libs.coil.compose)
    implementation(libs.timber)
    implementation(libs.vico.compose)
    implementation(libs.vico.compose.m3)
    
    testImplementation(libs.junit.jupiter)
    testImplementation(libs.mockk)
    testImplementation(libs.kotlinx.coroutines.test)
    
    androidTestImplementation(libs.compose.ui.test.junit4)
    debugImplementation(libs.compose.ui.tooling)
    debugImplementation(libs.compose.ui.test.manifest)
}
```

### 12.2 ProGuard 规则

```proguard
# Keep data classes
-keep class com.periodvibe.data.local.entity.** { *; }
-keep class com.periodvibe.domain.model.** { *; }

# Keep Room entities
-keep @androidx.room.Entity class *
-keep class * extends androidx.room.RoomDatabase

# Keep Hilt generated classes
-keep class dagger.hilt.** { *; }
-keep class javax.inject.** { *; }
-keep class * extends dagger.hilt.android.internal.managers.ViewComponentManager$FragmentContextWrapper { *; }

# Keep serialization
-keepattributes *Annotation*
-keepattributes Signature
-keepattributes InnerClasses
-keep class com.periodvibe.** { *; }
-keepclassmembers class com.periodvibe.** { *; }
```

---

## 13. 最佳实践

### 13.1 错误处理

```kotlin
sealed class Resource<out T> {
    data class Success<T>(val data: T) : Resource<T>()
    data class Error(val message: String, val exception: Throwable? = null) : Resource<Nothing>()
    object Loading : Resource<Nothing>()
}

@Composable
fun <T> ResourceHandler(
    resource: Resource<T>,
    onSuccess: @Composable (T) -> Unit,
    onError: @Composable (String) -> Unit,
    onLoading: @Composable () -> Unit
) {
    when (resource) {
        is Resource.Success -> onSuccess(resource.data)
        is Resource.Error -> onError(resource.message)
        is Resource.Loading -> onLoading()
    }
}
```

### 13.2 日志记录

```kotlin
object AppLogger {
    private const val TAG = "PeriodVibe"
    
    fun d(message: String) {
        Timber.tag(TAG).d(message)
    }
    
    fun i(message: String) {
        Timber.tag(TAG).i(message)
    }
    
    fun w(message: String) {
        Timber.tag(TAG).w(message)
    }
    
    fun e(message: String, throwable: Throwable? = null) {
        if (throwable != null) {
            Timber.tag(TAG).e(throwable, message)
        } else {
            Timber.tag(TAG).e(message)
        }
    }
}
```

### 13.3 常量管理

```kotlin
object Constants {
    object Database {
        const val NAME = "period_vibe.db"
        const val VERSION = 1
    }
    
    object Notification {
        const val CHANNEL_ID = "period_reminder"
        const val CHANNEL_NAME = "经期提醒"
        const val NOTIFICATION_ID = 1001
    }
    
    object Preferences {
        const val KEY_FIRST_LAUNCH = "first_launch"
        const val KEY_THEME_MODE = "theme_mode"
        const val KEY_NOTIFICATION_ENABLED = "notification_enabled"
    }
    
    object Date {
        const val DATE_FORMAT = "yyyy-MM-dd"
        const val DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss"
    }
}
```

---

## 14. 总结

本开发指南提供了 Period Vibe 应用的完整技术实现方案，包括：

- **技术栈选择**：基于 Jetpack Compose 和 Kotlin 的现代化技术栈
- **架构设计**：Clean Architecture + MVVM
- **数据库设计**：Room Database + Flow 响应式查询
- **导航设计**：Jetpack Navigation Compose
- **依赖注入**：Hilt
- **状态管理**：StateFlow + SharedFlow
- **代码规范**：Kotlin 和 Compose 最佳实践
- **测试策略**：单元测试、UI 测试、集成测试
- **性能优化**：Compose 优化、数据库优化、内存优化
- **安全规范**：数据加密、应用锁
- **构建发布**：Gradle 配置、ProGuard 规则

遵循本指南可以确保代码质量、可维护性和可扩展性，为 Period Vibe 应用的成功交付奠定坚实基础。

---

**文档版本**：v1.0
**创建日期**：2025-12-31
**作者**：Tech Lead
**状态**：待评审
