# Period Vibe - 数据建模方案

## 1. 建模概述

### 1.1 建模原则
- **Clean Architecture**：严格分层，Domain Layer不依赖任何框架
- **单一职责**：每个实体只负责一个核心概念
- **不可变性**：使用data class + val保证数据不可变
- **类型安全**：使用密封类和枚举确保类型安全
- **业务逻辑封装**：将业务逻辑封装在领域模型中

### 1.2 分层架构
```
┌─────────────────────────────────────────────────────────┐
│                  Presentation Layer                      │
│              (ViewModels, UI Components)                 │
└─────────────────────────────────────────────────────────┘
                           │ 使用
                           ▼
┌─────────────────────────────────────────────────────────┐
│                   Domain Layer                          │
│            (Domain Models, Use Cases)                    │
│  - Cycle, DailyRecord, Prediction, Settings             │
│  - FlowLevel, Symptom, CyclePhase                        │
└─────────────────────────────────────────────────────────┘
                           │ 映射
                           ▼
┌─────────────────────────────────────────────────────────┐
│                    Data Layer                           │
│     (Entities, DAOs, Repositories, Mappers)            │
│  - CycleEntity, DailyRecordEntity, SettingsEntity       │
└─────────────────────────────────────────────────────────┘
```

---

## 2. Domain Layer - 领域模型

### 2.1 核心领域模型

#### 2.1.1 Cycle（周期模型）
```kotlin
package com.periodvibe.domain.model

data class Cycle(
    val id: Long = 0,
    val startDate: LocalDate,
    val endDate: LocalDate?,
    val cycleLength: Int?,
    val periodLength: Int?,
    val averageFlowLevel: FlowLevel? = null,
    val isCompleted: Boolean = false,
    val createdAt: LocalDateTime = LocalDateTime.now(),
    val updatedAt: LocalDateTime = LocalDateTime.now()
) {
    val isCurrentCycle: Boolean
        get() = !isCompleted

    val duration: Int
        get() = if (endDate != null) {
            Period.between(startDate, endDate).days
        } else {
            Period.between(startDate, LocalDate.now()).days
        }

    fun complete(endDate: LocalDate): Cycle {
        return copy(
            endDate = endDate,
            cycleLength = Period.between(startDate, endDate).days,
            isCompleted = true,
            updatedAt = LocalDateTime.now()
        )
    }

    fun updatePeriodLength(newLength: Int): Cycle {
        return copy(periodLength = newLength, updatedAt = LocalDateTime.now())
    }
}
```

#### 2.1.2 DailyRecord（每日记录模型）
```kotlin
package com.periodvibe.domain.model

data class DailyRecord(
    val id: Long = 0,
    val date: LocalDate,
    val cycleId: Long?,
    val isPeriod: Boolean,
    val flowLevel: FlowLevel? = null,
    val symptoms: List<Symptom> = emptyList(),
    val notes: String? = null,
    val createdAt: LocalDateTime = LocalDateTime.now(),
    val updatedAt: LocalDateTime = LocalDateTime.now()
) {
    val hasSymptoms: Boolean
        get() = symptoms.isNotEmpty()

    val hasNotes: Boolean
        get() = !notes.isNullOrBlank()

    fun updatePeriodStatus(isPeriod: Boolean): DailyRecord {
        return copy(
            isPeriod = isPeriod,
            flowLevel = if (isPeriod) flowLevel ?: FlowLevel.LIGHT else null,
            updatedAt = LocalDateTime.now()
        )
    }

    fun updateFlowLevel(flowLevel: FlowLevel): DailyRecord {
        return copy(
            flowLevel = flowLevel,
            isPeriod = true,
            updatedAt = LocalDateTime.now()
        )
    }

    fun addSymptom(symptom: Symptom): DailyRecord {
        return copy(
            symptoms = if (symptom in symptoms) symptoms else symptoms + symptom,
            updatedAt = LocalDateTime.now()
        )
    }

    fun removeSymptom(symptom: Symptom): DailyRecord {
        return copy(
            symptoms = symptoms - symptom,
            updatedAt = LocalDateTime.now()
        )
    }

    fun updateNotes(notes: String?): DailyRecord {
        return copy(
            notes = notes?.takeIf { it.isNotBlank() },
            updatedAt = LocalDateTime.now()
        )
    }
}
```

#### 2.1.3 Prediction（预测模型）
```kotlin
package com.periodvibe.domain.model

data class Prediction(
    val nextPeriodStart: LocalDate,
    val nextPeriodEnd: LocalDate,
    val ovulationDate: LocalDate,
    val ovulationWindow: ClosedRange<LocalDate>,
    val fertileWindow: ClosedRange<LocalDate>,
    val confidence: Float,
    val predictedCycleLength: Int,
    val predictedPeriodLength: Int
) {
    val daysUntilPeriod: Int
        get() = Period.between(LocalDate.now(), nextPeriodStart).days

    val daysUntilOvulation: Int
        get() = Period.between(LocalDate.now(), ovulationDate).days

    val isInPeriodWindow: Boolean
        get() = LocalDate.now() in nextPeriodStart..nextPeriodEnd

    val isInOvulationWindow: Boolean
        get() = LocalDate.now() in ovulationWindow

    val isInFertileWindow: Boolean
        get() = LocalDate.now() in fertileWindow

    val confidenceLevel: ConfidenceLevel
        get() = when {
            confidence >= 0.8f -> ConfidenceLevel.HIGH
            confidence >= 0.5f -> ConfidenceLevel.MEDIUM
            else -> ConfidenceLevel.LOW
        }

    enum class ConfidenceLevel {
        HIGH, MEDIUM, LOW
    }
}
```

#### 2.1.4 Settings（设置模型）
```kotlin
package com.periodvibe.domain.model

data class Settings(
    val cycleLengthDefault: Int = 28,
    val periodLengthDefault: Int = 5,
    val cycleLengthRange: IntRange = 21..35,
    val periodLengthRange: IntRange = 3..7,
    val notificationEnabled: Boolean = true,
    val notificationDaysBefore: Int = 3,
    val notificationTime: LocalTime = LocalTime.of(9, 0),
    val themeMode: ThemeMode = ThemeMode.SYSTEM,
    val appLockEnabled: Boolean = false,
    val privacyModeEnabled: Boolean = false,
    val language: String = "zh"
) {
    enum class ThemeMode {
        LIGHT, DARK, SYSTEM
    }

    fun updateNotificationSettings(
        enabled: Boolean,
        daysBefore: Int,
        time: LocalTime
    ): Settings {
        return copy(
            notificationEnabled = enabled,
            notificationDaysBefore = daysBefore,
            notificationTime = time
        )
    }

    fun updateThemeMode(mode: ThemeMode): Settings {
        return copy(themeMode = mode)
    }

    fun updateCycleParameters(
        cycleLength: Int,
        periodLength: Int
    ): Settings {
        return copy(
            cycleLengthDefault = cycleLength,
            periodLengthDefault = periodLength
        )
    }
}
```

#### 2.1.5 CycleStatistics（周期统计模型）
```kotlin
package com.periodvibe.domain.model

data class CycleStatistics(
    val totalCycles: Int,
    val averageCycleLength: Double,
    val averagePeriodLength: Double,
    val shortestCycle: Int,
    val longestCycle: Int,
    val shortestPeriod: Int,
    val longestPeriod: Int,
    val regularityScore: RegularityScore,
    val totalRecordDays: Int,
    val cycleLengths: List<Int>,
    val periodLengths: List<Int>
) {
    val cycleLengthVariance: Double
        get() = calculateVariance(cycleLengths)

    val periodLengthVariance: Double
        get() = calculateVariance(periodLengths)

    val cycleLengthStandardDeviation: Double
        get() = kotlin.math.sqrt(cycleLengthVariance)

    val periodLengthStandardDeviation: Double
        get() = kotlin.math.sqrt(periodLengthVariance)

    private fun calculateVariance(values: List<Int>): Double {
        if (values.isEmpty()) return 0.0
        val mean = values.average()
        return values.map { (it - mean).pow(2) }.average()
    }

    enum class RegularityScore(val label: String, val color: String) {
        VERY_REGULAR("非常规律", "#4CAF50"),
        REGULAR("规律", "#8BC34A"),
        SOMEWHAT_REGULAR("不太规律", "#FFC107"),
        IRREGULAR("不规律", "#FF9800"),
        VERY_IRREGULAR("很不规律", "#F44336");

        companion object {
            fun fromCoefficientOfVariation(cv: Double): RegularityScore {
                return when {
                    cv < 0.10 -> VERY_REGULAR
                    cv < 0.20 -> REGULAR
                    cv < 0.30 -> SOMEWHAT_REGULAR
                    cv < 0.40 -> IRREGULAR
                    else -> VERY_IRREGULAR
                }
            }
        }
    }
}
```

### 2.2 枚举和密封类

#### 2.2.1 FlowLevel（经量枚举）
```kotlin
package com.periodvibe.domain.model

enum class FlowLevel(val displayName: String, val color: String, val value: Int) {
    LIGHT("少", "#FFCDD2", 1),
    MEDIUM("中", "#EF9A9A", 2),
    HEAVY("多", "#EF5350", 3);

    companion object {
        fun fromValue(value: Int): FlowLevel? {
            return values.find { it.value == value }
        }
    }
}
```

#### 2.2.2 Symptom（症状枚举）
```kotlin
package com.periodvibe.domain.model

enum class Symptom(
    val displayName: String,
    val icon: String,
    val category: SymptomCategory
) {
    ABDOMINAL_PAIN("腹痛", "abdominal_pain", SymptomCategory.PHYSICAL),
    LOWER_BACK_PAIN("腰痛", "lower_back_pain", SymptomCategory.PHYSICAL),
    BREAST_TENDERNESS("乳房胀痛", "breast_tenderness", SymptomCategory.PHYSICAL),
    HEADACHE("头痛", "headache", SymptomCategory.PHYSICAL),
    FATIGUE("疲劳", "fatigue", SymptomCategory.PHYSICAL),
    MOOD_SWINGS("情绪波动", "mood_swings", SymptomCategory.EMOTIONAL),
    IRRITABILITY("易怒", "irritability", SymptomCategory.EMOTIONAL),
    ANXIETY("焦虑", "anxiety", SymptomCategory.EMOTIONAL),
    BLOATING("腹胀", "bloating", SymptomCategory.PHYSICAL),
    NAUSEA("恶心", "nausea", SymptomCategory.PHYSICAL),
    ACNE("痘痘", "acne", SymptomCategory.PHYSICAL),
    INSOMNIA("失眠", "insomnia", SymptomCategory.EMOTIONAL),
    APPETITE_CHANGES("食欲变化", "appetite_changes", SymptomCategory.PHYSICAL),
    OTHER("其他", "other", SymptomCategory.OTHER);

    enum class SymptomCategory {
        PHYSICAL, EMOTIONAL, OTHER
    }
}
```

#### 2.2.3 CyclePhase（周期阶段枚举）
```kotlin
package com.periodvibe.domain.model

enum class CyclePhase(
    val displayName: String,
    val color: String,
    val description: String
) {
    MENSTRATION("经期", "#FF6B6B", "生理期"),
    FOLLICULAR("卵泡期", "#95E1D3", "卵泡发育期"),
    OVULATION("排卵期", "#4ECDC4", "排卵日前后"),
    LUTEAL("黄体期", "#FFB6C1", "黄体形成期"),
    FERTILE("易孕期", "#FFB6C1", "易受孕期"),
    SAFE("安全期", "#95E1D3", "不易受孕期");

    companion object {
        fun fromDate(
            date: LocalDate,
            prediction: Prediction?,
            currentCycle: Cycle?
        ): CyclePhase {
            if (currentCycle != null && currentCycle.isCurrentCycle) {
                val cycleDay = Period.between(currentCycle.startDate, date).days
                return when {
                    cycleDay < currentCycle.periodLength -> MENSTRATION
                    cycleDay < currentCycle.cycleLength - 14 - 3 -> FOLLICULAR
                    cycleDay < currentCycle.cycleLength - 14 + 3 -> OVULATION
                    else -> LUTEAL
                }
            }

            prediction?.let {
                return when {
                    date in it.fertileWindow -> FERTILE
                    date in it.ovulationWindow -> OVULATION
                    date in it.nextPeriodStart..it.nextPeriodEnd -> MENSTRATION
                    else -> SAFE
                }
            }

            return SAFE
        }
    }
}
```

#### 2.2.4 NotificationType（通知类型枚举）
```kotlin
package com.periodvibe.domain.model

enum class NotificationType(
    val displayName: String,
    val defaultEnabled: Boolean,
    val description: String
) {
    PERIOD_START("经期开始提醒", true, "经期开始前提醒"),
    PERIOD_END("经期结束提醒", true, "经期结束时提醒"),
    OVULATION("排卵期提醒", true, "排卵期开始前提醒"),
    FERTILE("易孕期提醒", true, "易孕期开始前提醒"),
    DAILY_RECORD("每日记录提醒", true, "每日提醒记录状态"),
    CYCLE_SUMMARY("周期总结", false, "周期结束后发送总结")
}
```

### 2.3 值对象（Value Objects）

#### 2.3.1 DateRange（日期范围）
```kotlin
package com.periodvibe.domain.model

data class DateRange(
    val startDate: LocalDate,
    val endDate: LocalDate
) {
    init {
        require(startDate <= endDate) { "Start date must be before or equal to end date" }
    }

    val duration: Int
        get() = Period.between(startDate, endDate).days + 1

    val dates: List<LocalDate>
        get() = generateSequence(startDate) { it.plusDays(1) }
            .take(duration)
            .toList()

    fun contains(date: LocalDate): Boolean {
        return date in startDate..endDate
    }

    fun overlaps(other: DateRange): Boolean {
        return startDate <= other.endDate && endDate >= other.startDate
    }

    fun expand(days: Int): DateRange {
        return DateRange(
            startDate.minusDays(days.toLong()),
            endDate.plusDays(days.toLong())
        )
    }

    companion object {
        fun fromMonth(year: Int, month: Int): DateRange {
            return DateRange(
                startDate = LocalDate.of(year, month, 1),
                endDate = LocalDate.of(year, month, 1)
                    .plusMonths(1)
                    .minusDays(1)
            )
        }
    }
}
```

#### 2.3.2 CycleInfo（周期信息）
```kotlin
package com.periodvibe.domain.model

data class CycleInfo(
    val cycle: Cycle,
    val phase: CyclePhase,
    val dayInCycle: Int,
    val daysUntilNextPeriod: Int?,
    val prediction: Prediction?
) {
    val isPeriod: Boolean
        get() = phase == CyclePhase.MENSTRATION

    val isOvulation: Boolean
        get() = phase == CyclePhase.OVULATION

    val isFertile: Boolean
        get() = phase == CyclePhase.FERTILE
}
```

---

## 3. Data Layer - 数据库实体

### 3.1 CycleEntity（周期实体）
```kotlin
package com.periodvibe.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.Index
import androidx.room.ForeignKey
import java.time.LocalDate
import java.time.LocalDateTime

@Entity(
    tableName = "cycles",
    indices = [
        Index(value = ["start_date"]),
        Index(value = ["end_date"])
    ]
)
data class CycleEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,

    @ColumnInfo(name = "start_date")
    val startDate: LocalDate,

    @ColumnInfo(name = "end_date")
    val endDate: LocalDate?,

    @ColumnInfo(name = "cycle_length")
    val cycleLength: Int?,

    @ColumnInfo(name = "period_length")
    val periodLength: Int?,

    @ColumnInfo(name = "average_flow_level")
    val averageFlowLevel: String?,

    @ColumnInfo(name = "is_completed")
    val isCompleted: Boolean = false,

    @ColumnInfo(name = "created_at")
    val createdAt: LocalDateTime,

    @ColumnInfo(name = "updated_at")
    val updatedAt: LocalDateTime
)
```

### 3.2 DailyRecordEntity（每日记录实体）
```kotlin
package com.periodvibe.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.Index
import androidx.room.ForeignKey
import androidx.room.ColumnInfo
import java.time.LocalDate
import java.time.LocalDateTime

@Entity(
    tableName = "daily_records",
    foreignKeys = [
        ForeignKey(
            entity = CycleEntity::class,
            parentColumns = ["id"],
            childColumns = ["cycle_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["date"], unique = true),
        Index(value = ["cycle_id"]),
        Index(value = ["is_period"])
    ]
)
data class DailyRecordEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,

    @ColumnInfo(name = "date")
    val date: LocalDate,

    @ColumnInfo(name = "cycle_id")
    val cycleId: Long?,

    @ColumnInfo(name = "is_period")
    val isPeriod: Boolean,

    @ColumnInfo(name = "flow_level")
    val flowLevel: String?,

    @ColumnInfo(name = "symptoms")
    val symptoms: String,

    @ColumnInfo(name = "notes")
    val notes: String?,

    @ColumnInfo(name = "created_at")
    val createdAt: LocalDateTime,

    @ColumnInfo(name = "updated_at")
    val updatedAt: LocalDateTime
)
```

### 3.3 SettingsEntity（设置实体）
```kotlin
package com.periodvibe.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.ColumnInfo
import java.time.LocalTime

@Entity(tableName = "settings")
data class SettingsEntity(
    @PrimaryKey
    val id: Int = 1,

    @ColumnInfo(name = "cycle_length_default")
    val cycleLengthDefault: Int,

    @ColumnInfo(name = "period_length_default")
    val periodLengthDefault: Int,

    @ColumnInfo(name = "cycle_length_min")
    val cycleLengthMin: Int,

    @ColumnInfo(name = "cycle_length_max")
    val cycleLengthMax: Int,

    @ColumnInfo(name = "period_length_min")
    val periodLengthMin: Int,

    @ColumnInfo(name = "period_length_max")
    val periodLengthMax: Int,

    @ColumnInfo(name = "notification_enabled")
    val notificationEnabled: Boolean,

    @ColumnInfo(name = "notification_days_before")
    val notificationDaysBefore: Int,

    @ColumnInfo(name = "notification_time")
    val notificationTime: String,

    @ColumnInfo(name = "theme_mode")
    val themeMode: String,

    @ColumnInfo(name = "app_lock_enabled")
    val appLockEnabled: Boolean,

    @ColumnInfo(name = "privacy_mode_enabled")
    val privacyModeEnabled: Boolean,

    @ColumnInfo(name = "language")
    val language: String,

    @ColumnInfo(name = "updated_at")
    val updatedAt: Long
)
```

### 3.4 NotificationEntity（通知实体）
```kotlin
package com.periodvibe.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.Index
import androidx.room.ColumnInfo
import java.time.LocalDate
import java.time.LocalTime

@Entity(
    tableName = "notifications",
    indices = [
        Index(value = ["scheduled_date"]),
        Index(value = ["type"]),
        Index(value = ["is_sent"])
    ]
)
data class NotificationEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,

    @ColumnInfo(name = "type")
    val type: String,

    @ColumnInfo(name = "title")
    val title: String,

    @ColumnInfo(name = "message")
    val message: String,

    @ColumnInfo(name = "scheduled_date")
    val scheduledDate: LocalDate,

    @ColumnInfo(name = "scheduled_time")
    val scheduledTime: String,

    @ColumnInfo(name = "is_sent")
    val isSent: Boolean = false,

    @ColumnInfo(name = "sent_at")
    val sentAt: Long? = null,

    @ColumnInfo(name = "created_at")
    val createdAt: Long
)
```

---

## 4. 数据转换和映射器

### 4.1 CycleMapper（周期映射器）
```kotlin
package com.periodvibe.data.mapper

import com.periodvibe.data.local.entity.CycleEntity
import com.periodvibe.domain.model.Cycle
import com.periodvibe.domain.model.FlowLevel
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class CycleMapper @Inject constructor() {

    fun toDomain(entity: CycleEntity): Cycle {
        return Cycle(
            id = entity.id,
            startDate = entity.startDate,
            endDate = entity.endDate,
            cycleLength = entity.cycleLength,
            periodLength = entity.periodLength,
            averageFlowLevel = entity.averageFlowLevel?.let { FlowLevel.valueOf(it) },
            isCompleted = entity.isCompleted,
            createdAt = entity.createdAt,
            updatedAt = entity.updatedAt
        )
    }

    fun toEntity(domain: Cycle): CycleEntity {
        return CycleEntity(
            id = domain.id,
            startDate = domain.startDate,
            endDate = domain.endDate,
            cycleLength = domain.cycleLength,
            periodLength = domain.periodLength,
            averageFlowLevel = domain.averageFlowLevel?.name,
            isCompleted = domain.isCompleted,
            createdAt = domain.createdAt,
            updatedAt = domain.updatedAt
        )
    }

    fun toDomainList(entities: List<CycleEntity>): List<Cycle> {
        return entities.map { toDomain(it) }
    }

    fun toEntityList(domains: List<Cycle>): List<CycleEntity> {
        return domains.map { toEntity(it) }
    }
}
```

### 4.2 DailyRecordMapper（每日记录映射器）
```kotlin
package com.periodvibe.data.mapper

import com.periodvibe.data.local.entity.DailyRecordEntity
import com.periodvibe.domain.model.DailyRecord
import com.periodvibe.domain.model.FlowLevel
import com.periodvibe.domain.model.Symptom
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class DailyRecordMapper @Inject constructor() {

    fun toDomain(entity: DailyRecordEntity): DailyRecord {
        return DailyRecord(
            id = entity.id,
            date = entity.date,
            cycleId = entity.cycleId,
            isPeriod = entity.isPeriod,
            flowLevel = entity.flowLevel?.let { FlowLevel.valueOf(it) },
            symptoms = parseSymptoms(entity.symptoms),
            notes = entity.notes,
            createdAt = entity.createdAt,
            updatedAt = entity.updatedAt
        )
    }

    fun toEntity(domain: DailyRecord): DailyRecordEntity {
        return DailyRecordEntity(
            id = domain.id,
            date = domain.date,
            cycleId = domain.cycleId,
            isPeriod = domain.isPeriod,
            flowLevel = domain.flowLevel?.name,
            symptoms = serializeSymptoms(domain.symptoms),
            notes = domain.notes,
            createdAt = domain.createdAt,
            updatedAt = domain.updatedAt
        )
    }

    fun toDomainList(entities: List<DailyRecordEntity>): List<DailyRecord> {
        return entities.map { toDomain(it) }
    }

    fun toEntityList(domains: List<DailyRecord>): List<DailyRecordEntity> {
        return domains.map { toEntity(it) }
    }

    private fun parseSymptoms(symptomsString: String): List<Symptom> {
        if (symptomsString.isBlank()) return emptyList()
        return symptomsString.split(",")
            .mapNotNull { Symptom.values().find { symptom -> symptom.name == it.trim() } }
    }

    private fun serializeSymptoms(symptoms: List<Symptom>): String {
        return symptoms.joinToString(",") { it.name }
    }
}
```

### 4.3 SettingsMapper（设置映射器）
```kotlin
package com.periodvibe.data.mapper

import com.periodvibe.data.local.entity.SettingsEntity
import com.periodvibe.domain.model.Settings
import com.periodvibe.domain.model.Settings.ThemeMode
import java.time.LocalTime
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SettingsMapper @Inject constructor() {

    fun toDomain(entity: SettingsEntity): Settings {
        return Settings(
            cycleLengthDefault = entity.cycleLengthDefault,
            periodLengthDefault = entity.periodLengthDefault,
            cycleLengthRange = entity.cycleLengthMin..entity.cycleLengthMax,
            periodLengthRange = entity.periodLengthMin..entity.periodLengthMax,
            notificationEnabled = entity.notificationEnabled,
            notificationDaysBefore = entity.notificationDaysBefore,
            notificationTime = LocalTime.parse(entity.notificationTime),
            themeMode = ThemeMode.valueOf(entity.themeMode),
            appLockEnabled = entity.appLockEnabled,
            privacyModeEnabled = entity.privacyModeEnabled,
            language = entity.language
        )
    }

    fun toEntity(domain: Settings): SettingsEntity {
        return SettingsEntity(
            id = 1,
            cycleLengthDefault = domain.cycleLengthDefault,
            periodLengthDefault = domain.periodLengthDefault,
            cycleLengthMin = domain.cycleLengthRange.first,
            cycleLengthMax = domain.cycleLengthRange.last,
            periodLengthMin = domain.periodLengthRange.first,
            periodLengthMax = domain.periodLengthRange.last,
            notificationEnabled = domain.notificationEnabled,
            notificationDaysBefore = domain.notificationDaysBefore,
            notificationTime = domain.notificationTime.toString(),
            themeMode = domain.themeMode.name,
            appLockEnabled = domain.appLockEnabled,
            privacyModeEnabled = domain.privacyModeEnabled,
            language = domain.language,
            updatedAt = System.currentTimeMillis()
        )
    }
}
```

---

## 5. 数据库类型转换器

```kotlin
package com.periodvibe.data.local.converter

import androidx.room.TypeConverter
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.time.format.DateTimeFormatter

class Converters {
    private val dateFormatter = DateTimeFormatter.ISO_LOCAL_DATE
    private val dateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME
    private val timeFormatter = DateTimeFormatter.ISO_LOCAL_TIME

    @TypeConverter
    fun fromLocalDate(date: LocalDate?): String? {
        return date?.format(dateFormatter)
    }

    @TypeConverter
    fun toLocalDate(dateString: String?): LocalDate? {
        return dateString?.let { LocalDate.parse(it, dateFormatter) }
    }

    @TypeConverter
    fun fromLocalDateTime(dateTime: LocalDateTime?): String? {
        return dateTime?.format(dateTimeFormatter)
    }

    @TypeConverter
    fun toLocalDateTime(dateTimeString: String?): LocalDateTime? {
        return dateTimeString?.let { LocalDateTime.parse(it, dateTimeFormatter) }
    }

    @TypeConverter
    fun fromLocalTime(time: LocalTime?): String? {
        return time?.format(timeFormatter)
    }

    @TypeConverter
    fun toLocalTime(timeString: String?): LocalTime? {
        return timeString?.let { LocalTime.parse(it, timeFormatter) }
    }
}
```

---

## 6. Repository 接口定义

### 6.1 CycleRepository
```kotlin
package com.periodvibe.domain.repository

import com.periodvibe.domain.model.Cycle
import kotlinx.coroutines.flow.Flow

interface CycleRepository {
    fun getAllCycles(): Flow<List<Cycle>>
    fun getCycleById(id: Long): Flow<Cycle?>
    fun getLatestCycle(): Flow<Cycle?>
    fun getCycleByDate(date: java.time.LocalDate): Flow<Cycle?>
    suspend fun insertCycle(cycle: Cycle): Long
    suspend fun updateCycle(cycle: Cycle)
    suspend fun deleteCycle(cycle: Cycle)
    suspend fun deleteCycleById(id: Long)
    suspend fun getCycleCount(): Int
}
```

### 6.2 DailyRecordRepository
```kotlin
package com.periodvibe.domain.repository

import com.periodvibe.domain.model.DailyRecord
import kotlinx.coroutines.flow.Flow

interface DailyRecordRepository {
    fun getAllRecords(): Flow<List<DailyRecord>>
    fun getRecordByDate(date: java.time.LocalDate): Flow<DailyRecord?>
    fun getRecordsByDateRange(startDate: java.time.LocalDate, endDate: java.time.LocalDate): Flow<List<DailyRecord>>
    fun getRecordsByCycleId(cycleId: Long): Flow<List<DailyRecord>>
    suspend fun insertRecord(record: DailyRecord): Long
    suspend fun updateRecord(record: DailyRecord)
    suspend fun deleteRecord(record: DailyRecord)
    suspend fun deleteRecordByDate(date: java.time.LocalDate)
}
```

### 6.3 SettingsRepository
```kotlin
package com.periodvibe.domain.repository

import com.periodvibe.domain.model.Settings
import kotlinx.coroutines.flow.Flow

interface SettingsRepository {
    fun getSettings(): Flow<Settings>
    suspend fun updateSettings(settings: Settings)
    suspend fun resetSettings()
}
```

---

## 7. Use Case 定义

### 7.1 GetCurrentCycleUseCase
```kotlin
package com.periodvibe.domain.usecase

import com.periodvibe.domain.model.Cycle
import com.periodvibe.domain.repository.CycleRepository
import kotlinx.coroutines.flow.Flow
import javax.inject.Inject

class GetCurrentCycleUseCase @Inject constructor(
    private val cycleRepository: CycleRepository
) {
    operator fun invoke(): Flow<Cycle?> {
        return cycleRepository.getLatestCycle()
            .map { cycle ->
                if (cycle == null) null
                else if (cycle.endDate == null) cycle
                else null
            }
    }
}
```

### 7.2 PredictNextPeriodUseCase
```kotlin
package com.periodvibe.domain.usecase

import com.periodvibe.domain.model.Cycle
import com.periodvibe.domain.model.Prediction
import com.periodvibe.domain.repository.CycleRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import java.time.LocalDate
import javax.inject.Inject

class PredictNextPeriodUseCase @Inject constructor(
    private val cycleRepository: CycleRepository
) {
    operator fun invoke(): Flow<Prediction?> {
        return cycleRepository.getAllCycles()
            .map { cycles -> calculatePrediction(cycles) }
    }

    private fun calculatePrediction(cycles: List<Cycle>): Prediction? {
        val completedCycles = cycles.filter { it.endDate != null }.takeLast(6)

        if (completedCycles.size < 1) return null

        val avgCycleLength = completedCycles.map { it.cycleLength }.average().toInt()
        val avgPeriodLength = completedCycles.map { it.periodLength }.average().toInt()

        val lastCycle = completedCycles.last()
        val nextPeriodStart = lastCycle.endDate!!.plusDays(avgCycleLength.toLong())
        val nextPeriodEnd = nextPeriodStart.plusDays(avgPeriodLength.toLong() - 1)

        val ovulationDate = nextPeriodStart.minusDays(14)
        val ovulationWindow = ovulationDate.minusDays(2)..ovulationDate.plusDays(2)
        val fertileWindow = ovulationDate.minusDays(5)..ovulationDate.plusDays(1)

        val confidence = calculateConfidence(completedCycles)

        return Prediction(
            nextPeriodStart = nextPeriodStart,
            nextPeriodEnd = nextPeriodEnd,
            ovulationDate = ovulationDate,
            ovulationWindow = ovulationWindow,
            fertileWindow = fertileWindow,
            confidence = confidence,
            predictedCycleLength = avgCycleLength,
            predictedPeriodLength = avgPeriodLength
        )
    }

    private fun calculateConfidence(cycles: List<Cycle>): Float {
        if (cycles.size < 3) return 0.3f

        val lengths = cycles.map { it.cycleLength }
        val mean = lengths.average()
        val variance = lengths.map { (it - mean).pow(2) }.average()
        val stdDev = kotlin.math.sqrt(variance)

        return when {
            stdDev < 2 -> 0.9f
            stdDev < 4 -> 0.7f
            stdDev < 6 -> 0.5f
            else -> 0.3f
        }
    }
}
```

### 7.3 SaveDailyRecordUseCase
```kotlin
package com.periodvibe.domain.usecase

import com.periodvibe.domain.model.Cycle
import com.periodvibe.domain.model.DailyRecord
import com.periodvibe.domain.repository.CycleRepository
import com.periodvibe.domain.repository.DailyRecordRepository
import java.time.LocalDate
import javax.inject.Inject

class SaveDailyRecordUseCase @Inject constructor(
    private val dailyRecordRepository: DailyRecordRepository,
    private val cycleRepository: CycleRepository
) {
    suspend operator fun invoke(record: DailyRecord): Long {
        val existingRecord = dailyRecordRepository.getRecordByDate(record.date).firstOrNull()

        return if (existingRecord != null) {
            val updatedRecord = record.copy(id = existingRecord.id)
            dailyRecordRepository.updateRecord(updatedRecord)
            handleCycleUpdate(updatedRecord)
            existingRecord.id
        } else {
            val recordId = dailyRecordRepository.insertRecord(record)
            handleCycleUpdate(record)
            recordId
        }
    }

    private suspend fun handleCycleUpdate(record: DailyRecord) {
        if (record.isPeriod) {
            val currentCycle = cycleRepository.getLatestCycle().firstOrNull()

            if (currentCycle == null || currentCycle.endDate != null) {
                val newCycle = Cycle(
                    startDate = record.date,
                    endDate = null,
                    cycleLength = 28,
                    periodLength = 5
                )
                cycleRepository.insertCycle(newCycle)
            }
        }
    }
}
```

---

## 8. 数据验证

### 8.1 CycleValidator
```kotlin
package com.periodvibe.domain.validator

import com.periodvibe.domain.model.Cycle
import java.time.LocalDate

object CycleValidator {

    fun validate(cycle: Cycle): ValidationResult {
        val errors = mutableListOf<ValidationError>()

        if (cycle.startDate.isAfter(LocalDate.now())) {
            errors.add(ValidationError.START_DATE_IN_FUTURE)
        }

        if (cycle.endDate != null && cycle.endDate.isBefore(cycle.startDate)) {
            errors.add(ValidationError.END_DATE_BEFORE_START)
        }

        if (cycle.cycleLength < 21 || cycle.cycleLength > 35) {
            errors.add(ValidationError.INVALID_CYCLE_LENGTH)
        }

        if (cycle.periodLength < 3 || cycle.periodLength > 7) {
            errors.add(ValidationError.INVALID_PERIOD_LENGTH)
        }

        return ValidationResult(
            isValid = errors.isEmpty(),
            errors = errors
        )
    }

    enum class ValidationError {
        START_DATE_IN_FUTURE,
        END_DATE_BEFORE_START,
        INVALID_CYCLE_LENGTH,
        INVALID_PERIOD_LENGTH
    }

    data class ValidationResult(
        val isValid: Boolean,
        val errors: List<ValidationError>
    )
}
```

### 8.2 DailyRecordValidator
```kotlin
package com.periodvibe.domain.validator

import com.periodvibe.domain.model.DailyRecord
import java.time.LocalDate

object DailyRecordValidator {

    fun validate(record: DailyRecord): ValidationResult {
        val errors = mutableListOf<ValidationError>()

        if (record.date.isAfter(LocalDate.now())) {
            errors.add(ValidationError.DATE_IN_FUTURE)
        }

        if (!record.isPeriod && record.flowLevel != null) {
            errors.add(ValidationError.FLOW_LEVEL_WITHOUT_PERIOD)
        }

        if (record.isPeriod && record.flowLevel == null) {
            errors.add(ValidationError.PERIOD_WITHOUT_FLOW_LEVEL)
        }

        if (!record.notes.isNullOrBlank() && record.notes.length > 500) {
            errors.add(ValidationError.NOTES_TOO_LONG)
        }

        return ValidationResult(
            isValid = errors.isEmpty(),
            errors = errors
        )
    }

    enum class ValidationError {
        DATE_IN_FUTURE,
        FLOW_LEVEL_WITHOUT_PERIOD,
        PERIOD_WITHOUT_FLOW_LEVEL,
        NOTES_TOO_LONG
    }

    data class ValidationResult(
        val isValid: Boolean,
        val errors: List<ValidationError>
    )
}
```

---

## 9. 数据库迁移策略

### 9.1 迁移示例
```kotlin
package com.periodvibe.data.local.database

import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase

val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL(
            """
            ALTER TABLE daily_records 
            ADD COLUMN mood_level TEXT
            """.trimIndent()
        )
    }
}

val MIGRATION_2_3 = object : Migration(2, 3) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL(
            """
            CREATE TABLE IF NOT EXISTS notifications (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                type TEXT NOT NULL,
                title TEXT NOT NULL,
                message TEXT NOT NULL,
                scheduled_date TEXT NOT NULL,
                scheduled_time TEXT NOT NULL,
                is_sent INTEGER NOT NULL DEFAULT 0,
                sent_at INTEGER,
                created_at INTEGER NOT NULL
            )
            """.trimIndent()
        )

        database.execSQL(
            """
            CREATE INDEX IF NOT EXISTS index_notifications_scheduled_date 
            ON notifications(scheduled_date)
            """.trimIndent()
        )
    }
}
```

---

## 10. 总结

### 10.1 建模优势
1. **清晰的分层**：Domain Layer完全独立，易于测试和维护
2. **类型安全**：使用枚举和密封类确保数据完整性
3. **业务逻辑封装**：将业务逻辑封装在领域模型中
4. **可扩展性**：易于添加新字段和功能
5. **数据验证**：完整的验证机制确保数据质量

### 10.2 关键设计决策
1. **使用LocalDate/LocalDateTime**：Java 8时间API，类型安全
2. **Flow响应式数据**：与Compose完美集成
3. **Mapper分离**：Domain和Data层完全解耦
4. **Repository接口**：便于单元测试和依赖注入
5. **UseCase封装**：业务逻辑集中管理

### 10.3 最佳实践
1. **不可变数据**：使用val和data class
2. **单一职责**：每个类只负责一件事
3. **依赖注入**：使用Hilt管理依赖
4. **错误处理**：使用Result或Resource包装
5. **日志记录**：关键操作记录日志

---

**文档版本**：v1.0
**创建日期**：2025-12-31
**作者**：Android高级开发工程师
**状态**：待评审
